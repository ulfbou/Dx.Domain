// <authors>Ulf Bourelius (Original Author)</authors>
// <copyright file="GeneratedFileHeader.cs" company="Dx.Domain Team">
//     Copyright (c) 2025 Dx.Domain Team. All rights reserved.
// </copyright>
// <license>
//     This software is licensed under the MIT License.
//     See the project's root <c>LICENSE</c> file for details.
//     Contributions are welcome, subject to the terms of the project's license.
//     See the repository root <c>CONTRIBUTING.md</c> file for details.
// </license>
// ----------------------------------------------------------------------------------

using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;

namespace Dx.Domain.Generators.CodeGeneration
{
    /// <summary>
    /// Utilities for generating pedagogical file headers that teach by existing.
    /// </summary>
    /// <remarks>
    /// Generated code should be boring, step-through-ready, and clearly explain its purpose.
    /// Headers are architectural narration, not legal boilerplate.
    /// </remarks>
    public static class GeneratedFileHeader
    {
        private static readonly string[] AggregateInvariants = new[]
        {
            "Aggregate creation is controlled via factory methods",
            "State changes occur only via events",
            "Invariants are enforced at construction and mutation boundaries"
        };

        private static readonly string[] ValueObjectInvariants = new[]
        {
            "Value objects are immutable by design",
            "Equality is based on structural comparison",
            "No identity or lifecycle concerns"
        };

        private static readonly string[] TestInvariants = new[]
        {
            "Tests are generated to match the domain model structure",
            "Test data respects domain invariants",
            "Generated tests serve as usage examples"
        };

        /// <summary>
        /// Generates a pedagogical header for generated code.
        /// </summary>
        /// <param name="generatorName">The name of the generator (e.g., "Dx.Domain.Generators").</param>
        /// <param name="purpose">The architectural purpose of this file.</param>
        /// <param name="invariants">The invariants this generated code enforces.</param>
        /// <returns>A pedagogical header as a string.</returns>
        public static string Generate(
            string generatorName,
            string purpose,
            IEnumerable<string> invariants)
        {
            var sb = new StringBuilder();
            
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("// ----------------------------------------------------------------------------------");
            sb.Append("// This file is generated by ");
            sb.Append(generatorName);
            sb.AppendLine(".");
            sb.Append("// ");
            sb.Append(purpose);
            sb.AppendLine();
            sb.AppendLine("//");
            
            if (invariants?.Any() == true)
            {
                sb.AppendLine("// It exists to enforce the following invariants:");
                foreach (var invariant in invariants)
                {
                    sb.Append("//   - ");
                    sb.Append(invariant);
                    sb.AppendLine();
                }
                sb.AppendLine("//");
            }
            
            sb.AppendLine("// Do not modify this file manually.");
            sb.AppendLine("// Changes will be overwritten on the next generation.");
            sb.AppendLine("// ----------------------------------------------------------------------------------");
            sb.AppendLine();
            
            return sb.ToString();
        }

        /// <summary>
        /// Generates a simple pedagogical header for generated code.
        /// </summary>
        /// <param name="generatorName">The name of the generator.</param>
        /// <param name="purpose">The architectural purpose of this file.</param>
        /// <returns>A simple pedagogical header.</returns>
        public static string GenerateSimple(string generatorName, string purpose)
        {
            return Generate(generatorName, purpose, Enumerable.Empty<string>());
        }

        /// <summary>
        /// Generates a header for aggregate-related generated code.
        /// </summary>
        /// <param name="aggregateName">The name of the aggregate.</param>
        /// <returns>A pedagogical header for aggregate generation.</returns>
        public static string ForAggregate(string aggregateName)
        {
            return Generate(
                "Dx.Domain.Generators",
                string.Format(CultureInfo.InvariantCulture, "Provides factory and infrastructure support for the {0} aggregate.", aggregateName),
                AggregateInvariants);
        }

        /// <summary>
        /// Generates a header for value object-related generated code.
        /// </summary>
        /// <param name="valueObjectName">The name of the value object.</param>
        /// <returns>A pedagogical header for value object generation.</returns>
        public static string ForValueObject(string valueObjectName)
        {
            return Generate(
                "Dx.Domain.Generators",
                string.Format(CultureInfo.InvariantCulture, "Provides equality and structural support for the {0} value object.", valueObjectName),
                ValueObjectInvariants);
        }

        /// <summary>
        /// Generates a header for test-related generated code.
        /// </summary>
        /// <param name="targetType">The type being tested.</param>
        /// <returns>A pedagogical header for test generation.</returns>
        public static string ForTests(string targetType)
        {
            return Generate(
                "Dx.Domain.Generators",
                string.Format(CultureInfo.InvariantCulture, "Provides test infrastructure and fixtures for {0}.", targetType),
                TestInvariants);
        }
    }
}
